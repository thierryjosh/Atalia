;;;;
;;;;  chess-core : framework routines
;;;;  https://en.wikipedia.org/wiki/Chess_notation
;;;;  https://en.wikipedia.org/wiki/Algebraic_notation_(chess)
;;;;  http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm
;;;;  https://lispcookbook.github.io/cl-cookbook/arrays.html
;;;;  https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation
;;;;  https://en.wikipedia.org/wiki/En_passant
;;;;
(defvar *chess-cluster* "/home/arkho/.emacs.d/chess-games/clusters")
(defvar *king* "K")
(defvar *queen* "Q")
(defvar *knight* "N")
(defvar *rook* "R")
(defvar *bishop* "B")
(defvar *cpieces* "BKNQR")
(defvar *cpieces-1* "BNQR")
(defvar *cpieces-2* "PRNBQK")
(defvar *qcastle* "O-O-O")
(defvar *kcastle* "O-O")
(defvar *c-board-y* "12345678")
(defvar *c-board-x* "abcdefgh")
(defvar *c-seg-ply* nil)
(defvar *scid-eco* nil)
(defvar *chess-board* (make-array '(8 8) :initial-element "-"))
(defvar *chess-board-simu1* (make-array '(8 8) :initial-element "-"))
(defvar *w-candidates* nil)
(defvar *b-candidates* nil)
(defvar *white-pieces* "PRNBQK")
(defvar *white-army* "PRNBQ")
(defvar *black-pieces* "prnbqk")
(defvar *black-army* "prnbq")
(defvar *en-passant* nil)   ;is a cons example W . e4
(defvar *null-piece* "-")
(defvar *kcastle* "O-O")
(defvar *qcastle* "O-O-O")
(defvar *pawn-val* 100)
(defvar *knight-val* 213)
(defvar *bishop-val* 243)
(defvar *rook-val* 352)
(defvar *queen-val* 786)
(defvar *king-vala* (* 32 *queen-val*))
(defvar *king-valb* 90)
(defvar *cf-army* 1)
(defvar *cf-territory* 0.05)
(defvar *cf-open* 0.05)
(defvar *cf-allowed-depth* 2)
(defvar *cf-max-depth* 1024)
(defvar *cf-qual-set* 22)
(defvar *eco-ref* (make-array 1024 :fill-pointer 0 :adjustable t))
(defvar *cpred-ref* (make-array 1024 :fill-pointer 0 :adjustable t))
; de 0,0 Ã  7,7 white uppercase black lower case empty square -

(defun c-init-board (cb)
     (loop for i below (car (array-dimensions cb)) do
        (loop for j below (cadr (array-dimensions cb)) do
           (setf (aref cb i j) *null-piece*)
	     )
          )  
  (setf (aref cb 0 0) "R")
  (setf (aref cb 0 1) "N")
  (setf (aref cb 0 2) "B")
  (setf (aref cb 0 3) "Q")
  (setf (aref cb 0 4) "K")
  (setf (aref cb 0 5) "B")
  (setf (aref cb 0 6) "N")
  (setf (aref cb 0 7) "R")
  (setf (aref cb 1 0) "P")
  (setf (aref cb 1 1) "P")
  (setf (aref cb 1 2) "P")
  (setf (aref cb 1 3) "P")
  (setf (aref cb 1 4) "P")
  (setf (aref cb 1 5) "P")
  (setf (aref cb 1 6) "P")
  (setf (aref cb 1 7) "P")
  (setf (aref cb 6 0) "p")
  (setf (aref cb 6 1) "p")
  (setf (aref cb 6 2) "p")
  (setf (aref cb 6 3) "p")
  (setf (aref cb 6 4) "p")
  (setf (aref cb 6 5) "p")
  (setf (aref cb 6 6) "p")
  (setf (aref cb 6 7) "p")
  (setf (aref cb 7 0) "r")
  (setf (aref cb 7 1) "n")
  (setf (aref cb 7 2) "b")
  (setf (aref cb 7 3) "q")
  (setf (aref cb 7 4) "k")
  (setf (aref cb 7 5) "b")
  (setf (aref cb 7 6) "n")
  (setf (aref cb 7 7) "r")
  ;(setf *c-seg-ply* nil)
  (return-from c-init-board cb)
  )

(defun is-castling (mv)
  (if (OR (equal mv *kcastle*) (equal mv *qcastle*))
      (return-from is-castling t)
      (return-from is-castling nil))
  )

(defun is-promotion (c mv)
  (let ((b1  nil))
    (if (and (equal (length mv) 4) (equal (subseq mv 2 3) "=")
	     (not (equal  (position (coerce (elt mv 3) 'character) *cpieces-1*) nil))
	     (not (equal  (position (coerce (elt mv 0) 'character) *c-board-x*) nil)))
	(progn	  
          (if (and (equal c "W") (equal (subseq mv 1 2) "8"))(setf b1 t))
	  (if (and (equal c "B") (equal (subseq mv 1 2) "1"))(setf b1 t))
	  ))
    (return-from is-promotion b1)
    )
  )

(defun is-pawn-move (c mv)
  (let ((b1  nil))
    (if (and (equal (length mv) 2)
	     (not (equal  (position (coerce (elt mv 1) 'character) *c-board-y*) nil))
	     (not (equal  (position (coerce (elt mv 0) 'character) *c-board-x*) nil)))
	(progn
          (if (and (equal c "W") (> (parse-integer(subseq mv 1 2)) 2))(setf b1 t))
	  (if (and (equal c "B") (< (parse-integer(subseq mv 1 2)) 7))(setf b1 t))
	  ))
    (return-from is-pawn-move b1)
    )
  )

(defun is-pawn-move-with-check (c mv)
  (let ((b1  nil))
    (if (equal (length mv) 3)
	(progn
          (if (and  (equal (is-pawn-move c (subseq mv 0 2)) t)
		    (equal (subseq mv 2) "+"))
	      (setf b1 t))
	  ))
    (return-from is-pawn-move-with-check b1)
    )
  )

(defun is-pawn-move-with-checkmate (c mv)
  (let ((b1  nil))
    (if (equal (length mv) 3)
	(progn
          (if (and  (equal (is-pawn-move c (subseq mv 0 2)) t)
		    (equal (subseq mv 2) "#"))
	      (setf b1 t))
	  ))
    (return-from is-pawn-move-with-checkmate b1)
    )
  )

(defun is-piece-move (mv)
  (let ((b1 nil))
    (if (and (equal (length mv) 3)
	     (not (equal  (position (coerce (elt mv 0) 'character) *cpieces*) nil))
	     (not (equal  (position (coerce (elt mv 1) 'character) *c-board-x*) nil))
	     (not (equal  (position (coerce (elt mv 2) 'character) *c-board-y*) nil)))
	(setf b1 t))
    (return-from is-piece-move b1)
    )
  )

(defun is-piece-move-with-check (mv)
  (let ((b1 nil))
    (if (and (equal (length mv) 4)
	     (not (equal  (position (coerce (elt mv 0) 'character) *cpieces-1*) nil))
	     (not (equal  (position (coerce (elt mv 1) 'character) *c-board-x*) nil))
	     (not (equal  (position (coerce (elt mv 2) 'character) *c-board-y*) nil))
	     (equal (subseq mv 3) "+"))
	(setf b1 t))
    (return-from is-piece-move-with-check b1)
    )
  )

(defun is-piece-move-with-checkmate (mv)
  (let ((b1 nil))
    (if (and (equal (length mv) 4)
	     (not (equal  (position (coerce (elt mv 0) 'character) *cpieces-1*) nil))
	     (not (equal  (position (coerce (elt mv 1) 'character) *c-board-x*) nil))
	     (not (equal  (position (coerce (elt mv 2) 'character) *c-board-y*) nil))
	     (equal (subseq mv 3) "#"))
	(setf b1 t))
    (return-from is-piece-move-with-checkmate b1)
    )
  )

(defun is-capture (mv)
  (let ((b1 nil))
    (if (and (equal (length mv) 4)
	     (or (not (equal  (position (coerce (elt mv 0) 'character) *cpieces*) nil)) (not (equal  (position (coerce (elt mv 0) 'character) *c-board-x*) nil)))
	     (equal (subseq mv 1 2) "x")
	     (not (equal  (position (coerce (elt mv 2) 'character) *c-board-x*) nil))
	     (not (equal  (position (coerce (elt mv 3) 'character) *c-board-y*) nil)))
	(setf b1 t))
    (return-from is-capture b1)
    )
  )

(defun is-capture-with-check (mv)
  (let ((b1 nil))
    (if (and (equal (length mv) 5)
	     (or (not (equal  (position (coerce (elt mv 0) 'character) *cpieces-1*) nil)) (not (equal  (position (coerce (elt mv 0) 'character) *c-board-x*) nil)))
	     (equal (subseq mv 1 2) "x")
	     (not (equal  (position (coerce (elt mv 2) 'character) *c-board-x*) nil))
	     (not (equal  (position (coerce (elt mv 3) 'character) *c-board-y*) nil))
	     (equal (subseq mv 4) "+"))
	(setf b1 t))
    (return-from is-capture-with-check b1)
    )
  )

(defun is-capture-with-checkmate (mv)
  (let ((b1 nil))
    (if (and (equal (length mv) 5)
	     (or (not (equal  (position (coerce (elt mv 0) 'character) *cpieces-1*) nil)) (not (equal  (position (coerce (elt mv 0) 'character) *c-board-x*) nil)))
	     (equal (subseq mv 1 2) "x")
	     (not (equal  (position (coerce (elt mv 2) 'character) *c-board-x*) nil))
	     (not (equal  (position (coerce (elt mv 3) 'character) *c-board-y*) nil))
	     (equal (subseq mv 4) "#"))
	(setf b1 t))
    (return-from is-capture-with-checkmate b1)
    )
  )

(defun is-capture-and-promotion-with-check (c mv)
  (let ((b1 nil))
    (if (and (equal (length mv) 7)
	     (not (equal  (position (coerce (elt mv 0) 'character) *c-board-x*) nil))
	     (equal (subseq mv 1 2) "x")
	     (not (equal  (position (coerce (elt mv 2) 'character) *c-board-x*) nil))
	     (not (equal  (position (coerce (elt mv 3) 'character) *c-board-y*) nil))
	     (equal (subseq mv 4 5) "=")
	     (not (equal  (position (coerce (elt mv 5) 'character) *cpieces-1*) nil))
	     (equal (subseq mv 6) "+"))
	  (progn	  
          (if (and (equal c "W") (equal (subseq mv 3 4) "8"))(setf b1 t))
	  (if (and (equal c "B") (equal (subseq mv 3 4) "1"))(setf b1 t))
	  ))
    (return-from is-capture-and-promotion-with-check b1)
    )
  )

(defun is-capture-and-promotion-with-checkmate (c mv)
  (let ((b1 nil))
    (if (and (equal (length mv) 7)
	     (not (equal  (position (coerce (elt mv 0) 'character) *c-board-x*) nil))
	     (equal (subseq mv 1 2) "x")
	     (not (equal  (position (coerce (elt mv 2) 'character) *c-board-x*) nil))
	     (not (equal  (position (coerce (elt mv 3) 'character) *c-board-y*) nil))
	     (equal (subseq mv 4 5) "=")
	     (not (equal  (position (coerce (elt mv 5) 'character) *cpieces-1*) nil))
	     (equal (subseq mv 6) "#"))
	  (progn	  
          (if (and (equal c "W") (equal (subseq mv 3 4) "8"))(setf b1 t))
	  (if (and (equal c "B") (equal (subseq mv 3 4) "1"))(setf b1 t))
	  ))
    (return-from is-capture-and-promotion-with-checkmate b1)
    )
  )
					;must add disambiguating moves and not allow exd8+ or exd8#

(defun verify-move-syntax (c mv) ;c color W B or nil (unknown) mv algebraic notation ( e3, Nf3, ...)
  (if (equal (is-castling mv) t) (return-from verify-move-syntax 1))
  (if (equal (is-pawn-move c mv) t) (return-from verify-move-syntax 3))
  (if (equal (is-pawn-move-with-check c mv) t) (return-from verify-move-syntax 4))
  (if (equal (is-pawn-move-with-checkmate c mv) t) (return-from verify-move-syntax 5))
  (if (equal (is-piece-move mv) t) (return-from verify-move-syntax 6))
  (if (equal (is-piece-move-with-check mv) t) (return-from verify-move-syntax 7))
  (if (equal (is-piece-move-with-checkmate mv) t) (return-from verify-move-syntax 8))
  (if (equal (is-capture mv) t) (return-from verify-move-syntax 9))
  (if (equal (is-capture-with-check mv) t) (return-from verify-move-syntax 10))
  (if (equal (is-capture-with-checkmate mv) t) (return-from verify-move-syntax 11))
  (if (equal (is-promotion c mv) t) (return-from verify-move-syntax 2))
  (if (equal (is-capture-and-promotion-with-check c mv) t) (return-from verify-move-syntax 12))
  (if (equal (is-capture-and-promotion-with-checkmate c mv) t) (return-from verify-move-syntax 13))
  (return-from verify-move-syntax nil)
  )

(defun make-wb-moves (nr mw mb)
  (let ((mv2 nil))
    (verify-move-syntax "W" mw)
    (verify-move-syntax "B" mb)
    (setf mv2 (concatenate 'string nr '(#\.) " "  mw " " mb))
    (return-from make-wb-moves mv2)
  ))

(defun find-square (mv)  ;example Nf3 ---> f3   Qxe2+ ---> e2
  (let ((lw nil)(sq nil))
    (setf lw  (ppcre:all-matches-as-strings "[abcdefgh][1-8]" mv))
    (if (not (equal lw nil))(setf sq (elt lw 0)))
    (return-from find-square sq)
    )
  )

(defun copy-board (board)
  (let ((cb (make-array '(8 8) :initial-element "-")))
     (loop for i below (car (array-dimensions board)) do
        (loop for j below (cadr (array-dimensions board)) do
           (setf (aref cb i j) (aref board i j))
            )
	  )
     (return-from copy-board cb)
    )
  )

(defun convert-alg-ij (alg)  ;"e4" ---> (3.4)
  (let ((i nil)(j nil))
    (if (> (length alg) 2)(return-from convert-alg-ij nil))
    (setf i (- (read-from-string (subseq alg 1)) 1))
    (setf j (position (coerce (subseq alg 0 1) 'character) *c-board-x*))
    (return-from convert-alg-ij (cons i j))
    )
  )

(defun convert-ij-alg (i j) ;3 4 ---> "e4"
  (let ((alg-1 nil)(alg-2 nil)(s1 nil))
    (if (or (< i 0) (> i 7))(return-from convert-ij-alg nil))
    (if (or (< j 0) (> j 7))(return-from convert-ij-alg nil))
    (setf alg-1 (elt *c-board-x* j))
    (setf alg-2 (+ i 1))
    (setf s1 (concatenate 'string (format nil "~a" alg-1) (write-to-string alg-2)))
    (return-from convert-ij-alg s1)
    )
  )

(defun find-enemy-king (cb bw) ;if you are White where is the black king and vice versa
  (let ((sq nil)(pce nil))
    (if (equal bw "B")(setf pce "K"))
    (if (equal bw "W")(setf pce "k"))
    (loop for i below (car (array-dimensions cb)) do
        (loop for j below (cadr (array-dimensions cb)) do
          (if (equal (aref cb i j) pce)(return-from find-enemy-king (convert-ij-alg i j)))
            )
	 )
    (return-from find-enemy-king sq)
    ))

;on peut dÃ©tecter les menaces cachÃ©es (2nd level or more)  en enlevant la piÃ©ce qui menace puis en
;rÃ©Ã©valuant la menace pour voir s'il y en a une autre (exemple pion en diagonale puis fou 
(defun enum-threats (cb bw i j)   ;which are the threats  on square i,j (the one who demands(threatened) is bw) cb is a chess board
  (let ((square nil)(ls nil)(i1 nil)(j1 nil)(pce nil))
    (setf square (convert-ij-alg i j))    
    (if (equal square nil) (return-from enum-threats nil))
    ;if you are white then you are interested in threats from black and vice-versa
    ;returns cons formed withs square under trhreat . piece threatening
    ;(e5 . Qe2) Queen e2 theatens square e5
    (setf i1 (+ i 1))
    (setf j1 (- j 1))
    (loop
       (when (or (> i1 7)(< j1 0))(return))
       (setf pce (aref cb i1 j1)) 
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "K"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "B")(equal pce "Q"))
		 (push (cons square (concatenate 'string pce  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "p"))
                 (push (cons square (concatenate 'string  (convert-ij-alg i1 j1))) ls))
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "k"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "b")(equal pce "q"))
		 (push (cons square (concatenate 'string (make-uppercase pce)  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (+ i1 1))
       (setf j1 (- j1 1))
       )

    (setf i1 (- i 1))
    (setf j1 (- j 1))
    (loop
       (when (or (< i1 0)(< j1 0))(return))
       (setf pce (aref cb i1 j1)) 
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "P"))
                 (push (cons square (concatenate 'string  (convert-ij-alg i1 j1))) ls))
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "K"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "B")(equal pce "Q"))
		 (push (cons square (concatenate 'string pce  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "k"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "b")(equal pce "q"))
		 (push (cons square (concatenate 'string (make-uppercase pce)  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))            
       (setf i1 (- i1 1))
       (setf j1 (- j1 1))
       )

    (setf i1 (+ i 1))
    (setf j1 (+ j 1))
    (loop
       (when (or (> i1 7)(> j1 7))(return))
       (setf pce (aref cb i1 j1)) 
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "K"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "B")(equal pce "Q"))
		 (push (cons square (concatenate 'string pce  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "p"))
                 (push (cons square (concatenate 'string  (convert-ij-alg i1 j1))) ls))
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "k"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "b")(equal pce "q"))
		 (push (cons square (concatenate 'string (make-uppercase pce)  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))            
       (setf i1 (+ i1 1))
       (setf j1 (+ j1 1))
       )

    (setf i1 (- i 1))
    (setf j1 (+ j 1))
    (loop
       (when (or (< i1 0)(> j1 7))(return))
       (setf pce (aref cb i1 j1)) 
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "P"))
                 (push (cons square (concatenate 'string  (convert-ij-alg i1 j1))) ls))
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "K"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "B")(equal pce "Q"))
		 (push (cons square (concatenate 'string pce  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 1)(equal pce "k"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "b")(equal pce "q"))
		 (push (cons square (concatenate 'string (make-uppercase pce)  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (- i1 1))
       (setf j1 (+ j1 1))
       )    

    (setf i1 (+ i 1))
    (setf j1 j)
    (loop
       (when (> i1 7)(return))
       (setf pce (aref cb i1 j1)) 
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 0)(equal pce "K"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "R")(equal pce "Q"))
		 (push (cons square (concatenate 'string pce  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 0)(equal pce "k"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "r")(equal pce "q"))
		 (push (cons square (concatenate 'string (make-uppercase pce)  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (+ i1 1))
       )

    (setf i1 (- i 1))
    (setf j1 j)
    (loop
       (when (< i1 0)(return))
       (setf pce (aref cb i1 j1)) 
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 0)(equal pce "K"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "R")(equal pce "Q"))
		 (push (cons square (concatenate 'string pce  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 1)(equal (abs (- j j1)) 0)(equal pce "k"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "r")(equal pce "q"))
		 (push (cons square (concatenate 'string (make-uppercase pce)  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (- i1 1))
       )

    (setf i1 i)
    (setf j1 (- j 1))
    (loop
       (when (< j1 0)(return))
       (setf pce (aref cb i1 j1)) 
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 0)(equal (abs (- j j1)) 1)(equal pce "K"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "R")(equal pce "Q"))
		 (push (cons square (concatenate 'string pce  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 0)(equal (abs (- j j1)) 1)(equal pce "k"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "r")(equal pce "q"))
		 (push (cons square (concatenate 'string (make-uppercase pce)  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf j1 (- j1 1))
       )

    (setf i1 i)
    (setf j1 (+ j 1))
    (loop
       (when (> j1 7)(return))
       (setf pce (aref cb i1 j1)) 
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 0)(equal (abs (- j j1)) 1)(equal pce "K"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "R")(equal pce "Q"))
		 (push (cons square (concatenate 'string pce  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-pieces*) nil)))
	   (progn
	     (if (and (equal (abs (- i i1)) 0)(equal (abs (- j j1)) 1)(equal pce "k"))
                 (push (cons square (concatenate 'string "K"  (convert-ij-alg i1 j1))) ls))	     
             (if (or (equal pce "r")(equal pce "q"))
		 (push (cons square (concatenate 'string (make-uppercase pce)  (convert-ij-alg i1 j1))) ls))
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf j1 (+ j1 1))
       )

    ;knight threat
    (if (and (equal bw "W")(>= (- i 2) 0)(<= (+ j 1) 7))
	(progn
	  (setf pce (aref cb (- i 2) (+ j 1))) 
          (if (equal  pce  "n") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 2) (+ j 1)))) ls))
	  ))
    (if (and (equal bw "W")(>= (- i 2) 0)(>= (- j 1) 0))
	(progn
	  (setf pce (aref cb (- i 2) (- j 1))) 
          (if (equal  pce  "n") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 2) (- j 1)))) ls))
	  ))
    (if (and (equal bw "W")(>= (- i 1) 0)(<= (+ j 2) 7))
	(progn
	  (setf pce (aref cb (- i 1) (+ j 2))) 
          (if (equal  pce  "n") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 1) (+ j 2)))) ls))
	  ))
    (if (and (equal bw "W")(>= (- i 1) 0)(>= (- j 2) 0))
	(progn
	  (setf pce (aref cb (- i 1) (- j 2))) 
          (if (equal  pce  "n") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 1) (- j 2)))) ls))
	  ))
    (if (and (equal bw "W")(<= (+ i 1) 7)(<= (+ j 2) 7))
	(progn
	  (setf pce (aref cb (+ i 1) (+ j 2))) 
          (if (equal  pce  "n") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 1) (+ j 2)))) ls))
	  ))
    (if (and (equal bw "W")(<= (+ i 1) 7)(>= (- j 2) 0))
	(progn
	  (setf pce (aref cb (+ i 1) (- j 2))) 
          (if (equal  pce  "n") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 1) (- j 2)))) ls))
	  ))
    (if (and (equal bw "W")(<= (+ i 2) 7)(<= (+ j 1) 7))
	(progn
	  (setf pce (aref cb (+ i 2) (+ j 1))) 
          (if (equal  pce  "n") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 2) (+ j 1)))) ls))
	  ))
    (if (and (equal bw "W")(<= (+ i 2) 7)(>= (- j 1) 0))
	(progn
	  (setf pce (aref cb (+ i 2) (- j 1))) 
          (if (equal  pce  "n") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 2) (- j 1)))) ls))
	  ))

    (if (and (equal bw "B")(>= (- i 2) 0)(<= (+ j 1) 7))
	(progn
	  (setf pce (aref cb (- i 2) (+ j 1))) 
          (if (equal  pce  "N") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 2) (+ j 1)))) ls))
	  ))
    (if (and (equal bw "B")(>= (- i 2) 0)(>= (- j 1) 0))
	(progn
	  (setf pce (aref cb (- i 2) (- j 1))) 
          (if (equal  pce  "N") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 2) (- j 1)))) ls))
	  ))
    (if (and (equal bw "B")(>= (- i 1) 0)(<= (+ j 2) 7))
	(progn
	  (setf pce (aref cb (- i 1) (+ j 2))) 
          (if (equal  pce  "N") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 1) (+ j 2)))) ls))
	  ))
    (if (and (equal bw "B")(>= (- i 1) 0)(>= (- j 2) 0))
	(progn
	  (setf pce (aref cb (- i 1) (- j 2))) 
          (if (equal  pce  "N") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 1) (- j 2)))) ls))
	  ))
    (if (and (equal bw "B")(<= (+ i 1) 7)(<= (+ j 2) 7))
	(progn
	  (setf pce (aref cb (+ i 1) (+ j 2))) 
          (if (equal  pce  "N") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 1) (+ j 2)))) ls))
	  ))
    (if (and (equal bw "B")(<= (+ i 1) 7)(>= (- j 2) 0))
	(progn
	  (setf pce (aref cb (+ i 1) (- j 2))) 
          (if (equal  pce  "N") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 1) (- j 2)))) ls))
	  ))
    (if (and (equal bw "B")(<= (+ i 2) 7)(<= (+ j 1) 7))
	(progn
	  (setf pce (aref cb (+ i 2) (+ j 1))) 
          (if (equal  pce  "N") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 2) (+ j 1)))) ls))
	  ))
    (if (and (equal bw "B")(<= (+ i 2) 7)(>= (- j 1) 0))
	(progn
	  (setf pce (aref cb (+ i 2) (- j 1))) 
          (if (equal  pce  "N") 
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 2) (- j 1)))) ls))
	  ))
    ;(print ls)
    (return-from enum-threats ls)     
    ))    

(defun mv-checkmate ()
  ;checkmate if king check and cannot move to safe place or destroy threat
  ;example if 2 threats and can destroy but  cannot move ==> mate
  ;the purpose of mv-checkmate is to eval if + is in fact #
  
  (let ((res nil))

    (return-from  mv-checkmate res)
    )
  )

(defun mv-pawn-if-king (bw i j)
  (let ((s1 nil)(i1 nil)(j1 nil)(j2 nil))
    (if (equal bw "W") (setf i1 (+ i 1)))
    (if (equal bw "B") (setf i1 (- i 1)))     
    (setf j1 (+ j 1))
    (setf j2 (- j 1))   
    (if (and (>= i1 0)(<= i1 7)(>= j1 0)(<= j1 7))
	(progn
          (if (and (equal bw "W")(equal (aref *chess-board* i1 j1) "k"))(setf s1 "+"))
          (if (and (equal bw "B")(equal (aref *chess-board* i1 j1) "K"))(setf s1 "+"))	  
	  ))
    (if (and (>= i1 0)(<= i1 7)(>= j2 0)(<= j2 7))
	(progn
          (if (and (equal bw "W")(equal (aref *chess-board* i1 j2) "k"))(setf s1 "+"))
          (if (and (equal bw "B")(equal (aref *chess-board* i1 j2) "K"))(setf s1 "+"))	  
	  ))
    (if (equal s1 "+")
	(progn
           ;call mv-checkmate for bw,i,j and change to # if necessary
	  ))
    (return-from mv-pawn-if-king s1)
    )
  )

(defun mv-pawn (cb bw i j)
  (let ((square nil)(ls nil)(k nil))
    (setf square (convert-ij-alg i j))
    (if (equal square nil) (return-from mv-pawn nil))
    
    (if (and (equal bw "W")(equal i 1)(equal (aref cb 2 j) *null-piece*))
	(progn
	  ;(setf k (mv-pawn-if-king bw 2 j))
	  (push (cons square (concatenate 'string (convert-ij-alg 2 j) k)) ls)
	))
    
    (if (and (equal bw "W")(equal i 1)(equal (aref cb 2 j) *null-piece*)(equal (aref cb 3 j) *null-piece*))
	(progn
	  ;(setf k (mv-pawn-if-king bw 3 j))
	  (push (cons square (concatenate 'string (convert-ij-alg 3 j) k)) ls)
	))
    
    (if (and (equal bw "B")(equal i 6)(equal (aref cb 5 j) *null-piece*))
	(progn
	  ;(setf k (mv-pawn-if-king bw 5 j))
	  (push (cons square (concatenate 'string (convert-ij-alg 5 j) k)) ls)	  
	))
    
    (if (and (equal bw "B")(equal i 6)(equal (aref cb 5 j) *null-piece*)(equal (aref cb 4 j) *null-piece*))
	(progn
	  ;(setf k (mv-pawn-if-king bw 4 j))
	  (push (cons square (concatenate 'string (convert-ij-alg 4 j) k)) ls)
	))

    (if (and (equal bw "W")(> i 1)(< i 6))
	(progn
	  (if (equal (aref cb (+ i 1) j) *null-piece*)
	      (progn
	        ;(setf k (mv-pawn-if-king bw (+ i 1) j))
	        (push (cons square (concatenate 'string (convert-ij-alg (+ i 1) j) k)) ls)
		))
	))
    (if (and (equal bw "W")(equal i 6)(equal (aref cb 7 j) *null-piece*))
	(progn
	  (push (cons square (concatenate 'string (convert-ij-alg 7 j) "=Q")) ls)  
	  ))

    (if (and (equal bw "B")(> i 1)(< i 6))
	(progn
	  (if (equal (aref cb (- i 1) j) *null-piece*)
	      (progn
	        ;(setf k (mv-pawn-if-king bw (- i 1) j))
	        (push (cons square (concatenate 'string (convert-ij-alg (- i 1) j) k)) ls)
		))
	))
    (if (and (equal bw "B")(equal i 1)(equal (aref cb 0 j) *null-piece*))
	(progn
	  (push (cons square (concatenate 'string (convert-ij-alg 0 j) "=Q")) ls)  
	  ))
    ;verify if pawn can take a piece
    (if (and (equal bw "W")(>= i 1)(< i 6)(>= j 1))
	(progn
	  (if (not (equal  (position (coerce (aref cb (+ i 1) (- j 1)) 'character) *black-army*) nil))
              (push (cons square (concatenate 'string (subseq square 0 1) "x" (convert-ij-alg (+ i 1) (- j 1)))) ls))
	  ))
    (if (and (equal bw "W")(equal i 6)(>= j 1))
	(progn
	  (if (not (equal  (position (coerce (aref cb 7 (- j 1)) 'character) *black-army*) nil))
              (push (cons square (concatenate 'string (subseq square 0 1) "x" (convert-ij-alg 7 (- j 1)) "=Q")) ls)) 
	  ))
    (if (and (equal bw "W")(>= i 1)(< i 6)(<= j 6))
	(progn
	  (if (not (equal  (position (coerce (aref cb (+ i 1) (+ j 1)) 'character) *black-army*) nil))
              (push (cons square (concatenate 'string (subseq square 0 1) "x" (convert-ij-alg (+ i 1) (+ j 1)))) ls)) 
	  ))
    (if (and (equal bw "W")(equal i 6)(<= j 6))
	(progn
	  (if (not (equal  (position (coerce (aref cb 7 (+ j 1)) 'character) *black-army*) nil))	      
              (push (cons square (concatenate 'string (subseq square 0 1) "x" (convert-ij-alg 7 (+ j 1)) "=Q")) ls)) 
	  ))
    (if (and (equal bw "B")(<= i 6)(> i 1)(>= j 1))
	(progn
	  (if (not (equal  (position (coerce (aref cb (- i 1) (- j 1)) 'character) *white-army*) nil))  
              (push (cons square (concatenate 'string (subseq square 0 1) "x" (convert-ij-alg (- i 1) (- j 1)))) ls))
	  ))
    (if (and (equal bw "B")(equal i 1)(>= j 1))
	(progn
	  (if (not (equal  (position (coerce (aref cb 0 (- j 1)) 'character) *white-army*) nil))  	      
              (push (cons square (concatenate 'string (subseq square 0 1) "x" (convert-ij-alg 0 (- j 1)) "=Q")) ls)) 
	  ))
    (if (and (equal bw "B")(<= i 6)(> i 1)(<= j 6))
	(progn
	  (if (not (equal  (position (coerce (aref cb (- i 1) (+ j 1)) 'character) *white-army*) nil))  	      
              (push (cons square (concatenate 'string (subseq square 0 1) "x" (convert-ij-alg (- i 1) (+ j 1)))) ls)) 
	  ))
    (if (and (equal bw "B")(equal i 1)(<= j 6))
	(progn
	  (if (not (equal  (position (coerce (aref cb 0 (+ j 1)) 'character) *white-army*) nil)) 	      
              (push (cons square (concatenate 'string (subseq square 0 1) "x" (convert-ij-alg 0 (+ j 1)) "=Q")) ls)) 
	  ))    
    ;verify pawn en passant
     (if (and (equal bw "W")(equal i 4)(equal (car *en-passant*) "B")(> j 0))
        (if (equal (convert-ij-alg 4 (- j 1)) (cdr *en-passant*))
	    (push (cons square (concatenate 'string (subseq square 0 1) "x" (convert-ij-alg 5 (- j 1)))) ls))
	)
    (if (and (equal bw "W")(equal i 4)(equal (car *en-passant*) "B")(<= j 6))
        (if (equal (convert-ij-alg 4 (+ j 1)) (cdr *en-passant*))
	    (push (cons square (concatenate 'string (subseq square 0 1) "x"(convert-ij-alg 5 (+ j 1)))) ls))
	) 
    (if (and (equal bw "B")(equal i 3)(equal (car *en-passant*) "W")(> j 0))
        (if (equal (convert-ij-alg 3 (- j 1)) (cdr *en-passant*))
	    (push (cons square (concatenate 'string (subseq square 0 1) "x"(convert-ij-alg 2 (- j 1)))) ls))
	)
    (if (and (equal bw "B")(equal i 3)(equal (car *en-passant*) "W")(<= j 6))
        (if (equal (convert-ij-alg 3 (+ j 1)) (cdr *en-passant*))
	    (push (cons square (concatenate 'string (subseq square 0 1) "x"(convert-ij-alg 2 (+ j 1)))) ls))
	)          
    (return-from mv-pawn ls) 
    ))

(defun ep-condition (bw mv)
  (setf *en-passant* nil)
  (if (and (equal bw "W")(or (equal mv "a4")(equal mv "b4")(equal mv "c4")(equal mv "d4")
			     (equal mv "e4")(equal mv "f4")(equal mv "g4")(equal mv "h4")))
      (setf *en-passant* (cons "W" mv)))
  (if (and (equal bw "B")(or (equal mv "a5")(equal mv "b5")(equal mv "c5")(equal mv "d5")
			     (equal mv "e5")(equal mv "f5")(equal mv "g5")(equal mv "h5")))
      (setf *en-passant* (cons "B" mv)))  
  )

(defun mv-knight (cb bw i j)
  (let ((square nil)(ls nil))
    (setf square (convert-ij-alg i j))
    (if (equal square nil) (return-from mv-knight nil))
    
    (if (and (>= (- i 2) 0)(<= (+ j 1) 7))
	(progn
          (if (equal (aref cb (- i 2) (+ j 1)) *null-piece*)
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 2) (+ j 1)))) ls))
	  ))
    (if (and (>= (- i 2) 0)(>= (- j 1) 0))
	(progn
          (if (equal (aref cb (- i 2) (- j 1)) *null-piece*)
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 2) (- j 1)))) ls))
	  ))
    (if (and (>= (- i 1) 0)(<= (+ j 2) 7))
	(progn
          (if (equal (aref cb (- i 1) (+ j 2)) *null-piece*)
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 1) (+ j 2)))) ls))
	  ))
    (if (and (>= (- i 1) 0)(>= (- j 2) 0))
	(progn
          (if (equal (aref cb (- i 1) (- j 2)) *null-piece*)
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (- i 1) (- j 2)))) ls))
	  ))
    (if (and (<= (+ i 1) 7)(<= (+ j 2) 7))
	(progn
          (if (equal (aref cb (+ i 1) (+ j 2)) *null-piece*)
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 1) (+ j 2)))) ls))
	  ))
    (if (and (<= (+ i 1) 7)(>= (- j 2) 0))
	(progn
          (if (equal (aref cb (+ i 1) (- j 2)) *null-piece*)
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 1) (- j 2)))) ls))
	  ))
    (if (and (<= (+ i 2) 7)(<= (+ j 1) 7))
	(progn
          (if (equal (aref cb (+ i 2) (+ j 1)) *null-piece*)
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 2) (+ j 1)))) ls))
	  ))
    (if (and (<= (+ i 2) 7)(>= (- j 1) 0))
	(progn
          (if (equal (aref cb (+ i 2) (- j 1)) *null-piece*)
	      (push (cons square (concatenate 'string "N" (convert-ij-alg (+ i 2) (- j 1)))) ls))
	  ))

    ;if knight takes something verify check checkmate
    (if (and (equal bw "W")(>= (- i 2) 0)(<= (+ j 1) 7))
	(progn
          (if (not (equal  (position (coerce (aref cb (- i 2) (+ j 1)) 'character) *black-army*) nil)) 
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (- i 2) (+ j 1)))) ls))
	  ))
    (if (and (equal bw "W")(>= (- i 2) 0)(>= (- j 1) 0))
	(progn
          (if (not (equal  (position (coerce (aref cb (- i 2) (- j 1)) 'character) *black-army*) nil)) 
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (- i 2) (- j 1)))) ls))
	  ))
    (if (and (equal bw "W")(>= (- i 1) 0)(<= (+ j 2) 7))
	(progn
          (if (not (equal  (position (coerce (aref cb (- i 1) (+ j 2)) 'character) *black-army*) nil)) 
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (- i 1) (+ j 2)))) ls))
	  ))
    (if (and (equal bw "W")(>= (- i 1) 0)(>= (- j 2) 0))
	(progn
          (if (not (equal  (position (coerce (aref cb (- i 1) (- j 2)) 'character) *black-army*) nil))          
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (- i 1) (- j 2)))) ls))
	  ))
    (if (and (equal bw "W")(<= (+ i 1) 7)(<= (+ j 2) 7))
	(progn
          (if (not (equal  (position (coerce (aref cb (+ i 1) (+ j 2)) 'character) *black-army*) nil))          
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (+ i 1) (+ j 2)))) ls))
	  ))
    (if (and (equal bw "W")(<= (+ i 1) 7)(>= (- j 2) 0))
	(progn
          (if (not (equal  (position (coerce (aref cb (+ i 1) (- j 2)) 'character) *black-army*) nil))   
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (+ i 1) (- j 2)))) ls))
	  ))
    (if (and (equal bw "W")(<= (+ i 2) 7)(<= (+ j 1) 7))
	(progn
          (if (not (equal  (position (coerce (aref cb (+ i 2) (+ j 1)) 'character) *black-army*) nil))          
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (+ i 2) (+ j 1)))) ls))
	  ))
    (if (and (equal bw "W")(<= (+ i 2) 7)(>= (- j 1) 0))
	(progn
          (if (not (equal  (position (coerce (aref cb (+ i 2) (- j 1)) 'character) *black-army*) nil)) 
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (+ i 2) (- j 1)))) ls))
	  ))

    (if (and (equal bw "B")(>= (- i 2) 0)(<= (+ j 1) 7))
	(progn
          (if (not (equal  (position (coerce (aref cb (- i 2) (+ j 1)) 'character) *white-army*) nil)) 
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (- i 2) (+ j 1)))) ls))
	  ))
    (if (and (equal bw "B")(>= (- i 2) 0)(>= (- j 1) 0))
	(progn
          (if (not (equal  (position (coerce (aref cb (- i 2) (- j 1)) 'character) *white-army*) nil)) 
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (- i 2) (- j 1)))) ls))
	  ))
    (if (and (equal bw "B")(>= (- i 1) 0)(<= (+ j 2) 7))
	(progn
          (if (not (equal  (position (coerce (aref cb (- i 1) (+ j 2)) 'character) *white-army*) nil)) 
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (- i 1) (+ j 2)))) ls))
	  ))
    (if (and (equal bw "B")(>= (- i 1) 0)(>= (- j 2) 0))
	(progn
          (if (not (equal  (position (coerce (aref cb (- i 1) (- j 2)) 'character) *white-army*) nil))          
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (- i 1) (- j 2)))) ls))
	  ))
    (if (and (equal bw "B")(<= (+ i 1) 7)(<= (+ j 2) 7))
	(progn
          (if (not (equal  (position (coerce (aref cb (+ i 1) (+ j 2)) 'character) *white-army*) nil))          
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (+ i 1) (+ j 2)))) ls))
	  ))
    (if (and (equal bw "B")(<= (+ i 1) 7)(>= (- j 2) 0))
	(progn
          (if (not (equal  (position (coerce (aref cb (+ i 1) (- j 2)) 'character) *white-army*) nil))   
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (+ i 1) (- j 2)))) ls))
	  ))
    (if (and (equal bw "B")(<= (+ i 2) 7)(<= (+ j 1) 7))
	(progn
          (if (not (equal  (position (coerce (aref cb (+ i 2) (+ j 1)) 'character) *white-army*) nil))          
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (+ i 2) (+ j 1)))) ls))
	  ))
    (if (and (equal bw "B")(<= (+ i 2) 7)(>= (- j 1) 0))
	(progn
          (if (not (equal  (position (coerce (aref cb (+ i 2) (- j 1)) 'character) *white-army*) nil)) 
	      (push (cons square (concatenate 'string "Nx" (convert-ij-alg (+ i 2) (- j 1)))) ls))
	  ))
    
    (return-from mv-knight ls)     
    ))

(defun mv-bishop (cb bw i j)
  (let ((square nil)(ls nil)(i1 nil)(j1 nil))
    (setf square (convert-ij-alg i j))
    (if (equal square nil) (return-from mv-bishop nil))
    (setf i1 (+ i 1))
    (setf j1 (- j 1))
    (loop
       (when (or (> i1 7)(< j1 0))(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "B" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Bx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Bx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (+ i1 1))
       (setf j1 (- j1 1))
       )

    (setf i1 (- i 1))
    (setf j1 (- j 1))
    (loop
       (when (or (< i1 0)(< j1 0))(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "B" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Bx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Bx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))            
       (setf i1 (- i1 1))
       (setf j1 (- j1 1))
       )

    (setf i1 (+ i 1))
    (setf j1 (+ j 1))
    (loop
       (when (or (> i1 7)(> j1 7))(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "B" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Bx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Bx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))            
       (setf i1 (+ i1 1))
       (setf j1 (+ j1 1))
       )

    (setf i1 (- i 1))
    (setf j1 (+ j 1))
    (loop
       (when (or (< i1 0)(> j1 7))(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "B" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Bx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Bx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (- i1 1))
       (setf j1 (+ j1 1))
       )    
    (return-from mv-bishop ls)     
    ))

(defun mv-rook (cb bw i j)
  (let ((square nil)(ls nil)(i1 nil)(j1 nil))
    (setf square (convert-ij-alg i j))
    (if (equal square nil) (return-from mv-rook nil))
    (setf i1 (+ i 1))
    (setf j1 j)
    (loop
       (when (> i1 7)(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "R" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Rx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Rx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (+ i1 1))
       )

    (setf i1 (- i 1))
    (setf j1 j)
    (loop
       (when (< i1 0)(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "R" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Rx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Rx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (- i1 1))
       )

    (setf i1 i)
    (setf j1 (- j 1))
    (loop
       (when (< j1 0)(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "R" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Rx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Rx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf j1 (- j1 1))
       )

    (setf i1 i)
    (setf j1 (+ j 1))
    (loop
       (when (> j1 7)(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "R" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Rx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Rx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf j1 (+ j1 1))
       )
    
    (return-from mv-rook ls)     
    ))

(defun mv-queen (cb bw i j)
  (let ((square nil)(ls nil)(i1 nil)(j1 nil))
    (setf square (convert-ij-alg i j))
    (if (equal square nil) (return-from mv-queen nil))
    
    (setf i1 (+ i 1))
    (setf j1 (- j 1))
    (loop
       (when (or (> i1 7)(< j1 0))(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "Q" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (+ i1 1))
       (setf j1 (- j1 1))
       )

    (setf i1 (- i 1))
    (setf j1 (- j 1))
    (loop
       (when (or (< i1 0)(< j1 0))(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "Q" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))            
       (setf i1 (- i1 1))
       (setf j1 (- j1 1))
       )

    (setf i1 (+ i 1))
    (setf j1 (+ j 1))
    (loop
       (when (or (> i1 7)(> j1 7))(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "Q" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))            
       (setf i1 (+ i1 1))
       (setf j1 (+ j1 1))
       )

    (setf i1 (- i 1))
    (setf j1 (+ j 1))
    (loop
       (when (or (< i1 0)(> j1 7))(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "Q" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (- i1 1))
       (setf j1 (+ j1 1))
       )    

    (setf i1 (+ i 1))
    (setf j1 j)
    (loop
       (when (> i1 7)(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "Q" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (+ i1 1))
       )

    (setf i1 (- i 1))
    (setf j1 j)
    (loop
       (when (< i1 0)(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "Q" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf i1 (- i1 1))
       )

    (setf i1 i)
    (setf j1 (- j 1))
    (loop
       (when (< j1 0)(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "Q" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf j1 (- j1 1))
       )

    (setf i1 i)
    (setf j1 (+ j 1))
    (loop
       (when (> j1 7)(return))
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "Q" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Qx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (not (equal (aref cb i1 j1) *null-piece*))(return))       
       (setf j1 (+ j1 1))
       )
    
    (return-from mv-queen ls)     
    ))

(defun mv-king (cb bw i j)
  (let ((square nil)(ls nil)(i1 nil)(j1 nil))
    (setf square (convert-ij-alg i j))
    (if (equal square nil) (return-from mv-king nil))
    
    (setf i1 (+ i 1))
    (setf j1 (- j 1))
    ;(when (or (> i1 7)(< j1 0))(return))
    (if (and (<= i1 7) (>= j1 0))
	(progn
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "K" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))     
       ))

    (setf i1 (- i 1))
    (setf j1 (- j 1))
    ;(when (or (< i1 0)(< j1 0))(return))
    (if (and (>= i1 0) (>= j1 0))
	(progn
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "K" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))      
       ))

    (setf i1 (+ i 1))
    (setf j1 (+ j 1))
    ;(when (or (> i1 7)(> j1 7))(return))
    (if (and (<= i1 7) (<= j1 7))
	(progn
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "K" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))        
       ))
       
    (setf i1 (- i 1))
    (setf j1 (+ j 1))
    ;(when (or (< i1 0)(> j1 7))(return))
    (if (and (>= i1 0) (<= j1 7))
	(progn    
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "K" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))     
       ))

    (setf i1 (+ i 1))
    (setf j1 j)
    ;(when (> i1 7)(return))
    (if (<= i1 7)
	(progn    
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "K" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))    
       ))
       
    (setf i1 (- i 1))
    (setf j1 j)
    ;(when (< i1 0)(return))
    (if (>= i1 0)
	(progn    
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "K" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))    
       ))
       
    (setf i1 i)
    (setf j1 (- j 1))
    ;(when (< j1 0)(return))
    (if (>= j1 0)
	(progn    
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "K" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))      
       ))
       
    (setf i1 i)
    (setf j1 (+ j 1))
    ;(when (> j1 7)(return))
    (if (<= j1 7)
	(progn    
          (if (equal (aref cb i1 j1) *null-piece*)
	      (push (cons square (concatenate 'string "K" (convert-ij-alg i1 j1))) ls))
       (if (and (equal bw "B")(not (equal  (position (coerce (aref cb i1 j1) 'character) *white-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))
       (if (and (equal bw "W")(not (equal  (position (coerce (aref cb i1 j1) 'character) *black-army*) nil)))
	   (progn
             (push (cons square (concatenate 'string "Kx" (convert-ij-alg i1 j1))) ls)
	     ;(return)
	     ))      
       ))
    (if (and (equal bw "B")(equal i 7)(equal j 4)(equal (aref cb  7 5) *null-piece*) ;verif that never moved king and rook
	     (equal (aref cb 7 6) *null-piece*)(equal (aref cb 7 7) "r")(equal (enum-threats cb bw 7 5) nil)(equal (enum-threats cb bw 7 4) nil)
	     (equal (enum-threats cb bw 7 6) nil))
	(progn
	   (push (cons square *kcastle*) ls)
	    ;(return)
	   ))
    (if (and (equal bw "B")(equal i 7)(equal j 4)(equal (aref cb  7 3) *null-piece*)(equal (aref cb  7 2) *null-piece*) ;verif that never moved king and rook
	     (equal (aref cb 7 1) *null-piece*)(equal (aref cb 7 0) "r")(equal (enum-threats cb bw 7 3) nil)(equal (enum-threats cb bw 7 4) nil)
	     (equal (enum-threats cb bw 7 2) nil)(equal (enum-threats cb bw 7 1) nil))
	(progn
	   (push (cons square *qcastle*) ls)
	    ;(return)
	   ))
    (if (and (equal bw "W")(equal i 0)(equal j 4)(equal (aref cb  0 5) *null-piece*) ;verif that never moved king and rook
	     (equal (aref cb 0 6) *null-piece*)(equal (aref cb 0 7) "R")(equal (enum-threats cb bw 0 5) nil)(equal (enum-threats cb bw 0 4) nil)
	     (equal (enum-threats cb bw 0 6) nil))
	(progn
	   (push (cons square *kcastle*) ls)
	    ;(return)
	   ))
    (if (and (equal bw "W")(equal i 0)(equal j 4)(equal (aref cb  0 3) *null-piece*)(equal (aref cb  0 2) *null-piece*) ;verif that never moved king and rook
	     (equal (aref cb 0 1) *null-piece*)(equal (aref cb 0 0) "R")(equal (enum-threats cb bw 0 3) nil)(equal (enum-threats cb bw 0 4) nil)
	     (equal (enum-threats cb bw 0 2) nil)(equal (enum-threats cb bw 0 1) nil))
	(progn
	   (push (cons square *qcastle*) ls)
	    ;(return)
	   ))           
    (return-from mv-king ls)     
    ))

(defun get-squares (x y p)
  ;(print x)(print y)(print p)
  (let ((ls nil)(kx -1)(ky -1)(vx nil)(vy nil)(v1 -1)(v2 -1)(k1 -1)(p1 -1)(p2 -1)(p3 -1)(p4 -1)(s1 nil))
    (if (or (equal p "Q")(equal p "R"))
	(progn
          (if (equal (subseq x 1)(subseq y 1))  ;mÃªme chiffre
	      (progn
                (setf vx (subseq x 0 1))
		(setf vy (subseq y 0 1))
		(setf kx (position (coerce vx 'character) *c-board-x*))
		(setf ky (position (coerce vy 'character) *c-board-x*))
		;(print kx)(print ky)
		(setf k1 (+ (min  kx ky) 1))
		(loop
                   (when (> k1 (- (max kx ky) 1))(return))
		   (setf s1 (concatenate 'string (subseq *c-board-x* k1 (+ k1 1)) (subseq x 1)))
		   ;(print s1)
		   (push s1 ls)
		   (setf k1 (+ k1 1))
		     )
		))
	  (if (equal (subseq x 0 1)(subseq y 0 1)) ;mÃªme lettre
	      (progn
                (setf kx (read-from-string (subseq x 1)))
		(setf ky (read-from-string (subseq y 1)))
		;(print kx)(print ky)
		(setf k1 (+ (min  kx ky) 1))
		(loop
		   (when (> k1 (- (max kx ky) 1))(return))
		   (setf s1 (concatenate 'string (subseq x 0 1) (format nil "~a" k1)))
		   (push s1 ls)
		   (setf k1 (+ k1 1))		   
		     )
		))
	  ))
    (if (or (equal p "Q")(equal p "B"))
	(progn
          (setf vx (subseq x 0 1))
	  (setf vy (subseq y 0 1))
	  (setf v1 (position (coerce vx 'character) *c-board-x*))
	  (setf v2 (position (coerce vy 'character) *c-board-x*))	  
          (setf kx (read-from-string (subseq x 1)))
	  (setf ky (read-from-string (subseq y 1)))
	  (setf p1 (+ v1 1))
	  (setf p2 (- v2 1))
	  (setf p3 (- v1 1))
	  (setf p4 (+ v2 1))
	  (setf k1 (+ (min  kx ky) 1))
	  (loop
	     (when (> k1 (- (max kx ky) 1))(return))
	     ;(setf s1 (concatenate 'string (subseq x 0 1) (format nil "~a" k1)))
	     ;(push s1 ls)
             (if (and (< kx ky)(< v1 v2))
		 (progn
                   (setf s1 (concatenate 'string (format nil "~a" (aref *c-board-x* p1)) (format nil "~a" k1)))
		   (setf p1 (+ p1 1))
		   (push s1 ls)
		   ))
             (if (and (> kx ky)(> v1 v2))
		 (progn
                   (setf s1 (concatenate 'string (format nil "~a" (aref *c-board-x* p4)) (format nil "~a" k1)))
		   (setf p4 (+ p4 1))
		   (push s1 ls)
		   ))
             (if (and (> kx ky)(< v1 v2))
		 (progn
                   (setf s1 (concatenate 'string (format nil "~a" (aref *c-board-x* p2)) (format nil "~a" k1)))
		   (setf p2 (- p2 1))
		   (push s1 ls)
		   ))
             (if (and (< kx ky)(> v1 v2))
		 (progn
                   (setf s1 (concatenate 'string (format nil "~a" (aref *c-board-x* p3)) (format nil "~a" k1)))
		   (setf p3 (- p3 1))
		   (push s1 ls)
		   ))	     
	     (setf k1 (+ k1 1))		   
	       )
	  
	  ))
    ;(print ls)
    (return-from get-squares ls)
    )
  )

(defun is-checkmate (cb w wt bw ik jk)
    ;qd il qrrive ici le roi est dÃ©jÃ  en Ã©chec
    ;il est mat si 1) pas de safe square, ttes cases de move king under threat
    ;2) pas de threate sur la piÃ¨ce qui menace 
    ;3) pas d'interposition de piÃ¨ce (threat list = nil apres move interposition
  (let ((lk1 nil)(lk2 nil)(res "+")(cbz (make-array '(8 8) :initial-element "-"))(bw-opp nil)
        (i1 nil)(j1 nil)(i2 nil)(j2 nil)(sqx nil)(sqy nil)(pce nil)(threats nil)(b1 nil)(b2 nil)(b3 nil))	
  ;(setf w w) ;compile no warning
    (setf lk1 (mv-king cb bw ik jk))
    ;remove castle as possible move because king is check!!
    ;(print lk1)
    ;(terpri) (show-board2 cb)
    ;1) safe square exists ?
   (dolist (z1 lk1)
     (setf cbz (copy-board cb))
     
      (setf i1 (car (convert-alg-ij (car z1))))
      (setf j1 (cdr (convert-alg-ij (car z1))))
      (setf sqx (find-square (cdr z1)))
      (setf i2 (car (convert-alg-ij sqx)))
      (setf j2 (cdr (convert-alg-ij sqx)))
      ;(print i1)(print j1)(print i2)(print j2)
      (setf (aref cbz i2 j2) (aref cbz i1 j1))
      (setf (aref cbz i1 j1) *null-piece*)
      (setf threats (enum-threats cbz bw i2 j2))
      ;(print threats)
      (if (equal threats nil)
          (progn
	    (setf b1 T) ;il existe au moins une safe square
	    (return)
	    ))      
      )
    ;2) threat can be destroyed ?
    (if (equal bw "W")(setf bw-opp "B"))
    (if (equal bw "B")(setf bw-opp "W"))
    (setf threats nil)
    (if (or (equal (cdr w) *kcastle*)(equal (cdr w) *qcastle*))
	(progn
	  (if (and (equal (car w) "e8")(equal (cdr w) *kcastle*))(setf sqx "g8"))
          (if (and (equal (car w) "e8")(equal (cdr w) *qcastle*))(setf sqx "c8"))
	  (if (and (equal (car w) "e1")(equal (cdr w) *kcastle*))(setf sqx "g1"))
	  (if (and (equal (car w) "e1")(equal (cdr w) *qcastle*))(setf sqx "c1"))
	  )
        (setf sqx (find-square (cdr w))))  ;att sqx nil if castle
    (if (not (equal sqx nil))(progn			       
                               (setf i2 (car (convert-alg-ij sqx)))
                               (setf j2 (cdr (convert-alg-ij sqx)))
                               (setf threats (enum-threats cb bw-opp i2 j2))
			       ))

    ;(print threats)
    (if (not (equal threats nil))(setf b2 T)) ;il existe au moins un destroyer, check if destroyer is king
    ;3) interposition ?
    (setf sqx (find-square (car wt)))
    (setf sqy (find-square (cdr wt)))
    (setf pce (subseq (cdr wt) 0 1))
    (setf lk2 (get-squares sqx sqy pce))
    ;(print lk2)
    (dolist (z2 lk2)
      (setf i1 (car (convert-alg-ij z2)))
      (setf j1 (cdr (convert-alg-ij z2)))
      (setf threats (enum-threats cb bw-opp i1 j1))
      ;(print bw-opp)(print i1)(print j1)
      ;(print threats)
      (dolist (t1 threats)
        (if (not (equal (subseq (cdr t1) 0 1) "K"))
	    (progn        ;il faudrait peut etre vÃ©rifier que threats est nil aprÃ¨s le move d'interposition
              (setf b3 T) ;il existe au moins une piÃ¨ce qui n'est pas le roi et qui peut s'interposer
	      (return)
	      ))
	)
      )
    
    (if (and (equal b1 nil)(equal b2 nil)(equal b3 nil))(setf res "#")) 
    (return-from is-checkmate res)
    ))

(defun build-candidates (cb bw i j)   ; pour un i j particulier
  (let ((ls nil)(lsr nil)(sqx nil)(sqk nil)(cbs (make-array '(8 8) :initial-element "-"))
	(i1 nil)(j1 nil)(i2 nil)(j2 nil)(ik nil)(jk nil)(threats nil)(bw-opp nil)(res nil)(wt nil))
    (if (or (equal (aref cb i j) "P") (equal (aref cb i j) "p")) (setf ls (mv-pawn cb bw i j)))
    (if (or (equal (aref cb i j) "N") (equal (aref cb i j) "n")) (setf ls (mv-knight cb bw i j)))
    (if (or (equal (aref cb i j) "B") (equal (aref cb i j) "b")) (setf ls (mv-bishop cb bw i j)))
    (if (or (equal (aref cb i j) "R") (equal (aref cb i j) "r")) (setf ls (mv-rook cb bw i j)))
    (if (or (equal (aref cb i j) "Q") (equal (aref cb i j) "q")) (setf ls (mv-queen cb bw i j)))
    (if (or (equal (aref cb i j) "K") (equal (aref cb i j) "k")) (setf ls (mv-king cb bw i j)))

    (if (equal bw "W")(setf bw-opp "B"))
    (if (equal bw "B")(setf bw-opp "W"))
    (setf lsr nil)
    (dolist (w ls)
      ;(print w)
      (setf cbs (copy-board cb))
      (if (or (equal (cdr w) *kcastle*)(equal (cdr w) *qcastle*))
	  (progn
            ;(print (cdr w))(print bw)
	    (if (and (equal (car w) "e8")(equal (cdr w) *kcastle*))
		(progn
                  (setf (aref cbs 7 4) *null-piece*)
		  (setf (aref cbs 7 6) "k")
		  (setf (aref cbs 7 5) "r")
		  (setf (aref cbs 7 7) *null-piece*)
		  ))
	    (if (and (equal (car w) "e8")(equal (cdr w) *qcastle*))
		(progn
                  (setf (aref cbs 7 4) *null-piece*)
		  (setf (aref cbs 7 2) "k")
		  (setf (aref cbs 7 3) "r")
		  (setf (aref cbs 7 0) *null-piece*)
		  ))
	    (if (and (equal (car w) "e1")(equal (cdr w) *kcastle*))
		(progn
                  (setf (aref cbs 0 4) *null-piece*)
		  (setf (aref cbs 0 6) "K")
		  (setf (aref cbs 0 5) "R")
		  (setf (aref cbs 0 7) *null-piece*)
		  ))
	    (if (and (equal (car w) "e1")(equal (cdr w) *qcastle*))
		(progn
                  (setf (aref cbs 0 4) *null-piece*)
		  (setf (aref cbs 0 2) "K")
		  (setf (aref cbs 0 3) "R")
		  (setf (aref cbs 0 0) *null-piece*)
		  ))		  	    
	    )
	  (progn
            (setf i1 (car (convert-alg-ij (car w))))
            (setf j1 (cdr (convert-alg-ij (car w))))
            (setf sqx (find-square (cdr w)))
            (setf i2 (car (convert-alg-ij sqx)))
            (setf j2 (cdr (convert-alg-ij sqx)))
            ;(print i1)(print j1)(print i2)(print j2)
            (setf (aref cbs i2 j2) (aref cbs i1 j1))
            (setf (aref cbs i1 j1) *null-piece*)
	    ))
      ;(print cbs)(terpri)
      ;(show-board2 cbs) (terpri)
      (setf sqk (find-enemy-king cbs bw))
      ;(print sqk)
      (setf threats nil)
      (if (not (equal sqk nil))
	  (progn
            (setf ik (car (convert-alg-ij sqk)))
            (setf jk (cdr (convert-alg-ij sqk)))
	    (setf threats (enum-threats cbs bw-opp ik jk))
	    ))
      ;(print ik)(print jk)
      (setf res nil)(setf wt nil)
      (if (not (equal threats nil))
	  (progn
             ;do we have sqx in threats on enemy king 
            ;(print threats)
	    (dolist (k threats)
              (if (and (equal sqk (car k))(equal sqx (find-square (cdr w))))
		  (progn
		    ;(print sqk)(print k)(print sqx)(print (find-square (cdr w)))(terpri)
		    (setf wt k)
		    (setf res "+")
		    (return)
		    ))
	      )
	    ))
      (if (equal res "+")
	  (progn
	    ;(print w)(print wt)(print bw-opp)
            ;(setf lk1 (mv-king cbs bw-opp ik jk))
	    (setf res (is-checkmate cbs w wt bw-opp ik jk))
	    ))

      ;filter illegal moves (1/placing own king in check)
      (setf sqk (find-enemy-king cbs bw-opp))
      ;(print sqk)
      (setf threats nil)
      (if (not (equal sqk nil))
	  (progn
            (setf ik (car (convert-alg-ij sqk)))
            (setf jk (cdr (convert-alg-ij sqk)))
	    (setf threats (enum-threats cbs bw ik jk))
	    ))
      ;(print threats)
      (if (equal threats nil)
          (push (cons (car w) (concatenate 'string (cdr w) res)) lsr))
      )
    
    (return-from build-candidates lsr)
  ))

(defun remove-cdup (ls z)
  (let ((k (+ z 1))(s nil))
    (if (equal ls nil)(return-from remove-cdup nil))
    (when (> z (- (length ls) 1))(return-from remove-cdup ls))
    (loop
       (when (> k (- (length ls) 1))(return))
       (setf s (cdr (elt ls z)))
       (if (and (equal (cdr (elt ls k)) (cdr (elt ls z)))(not (equal (position (coerce (elt s 0) 'character) *cpieces-2*) nil)))
	   (progn
             (setf (elt ls z) (cons (car (elt ls z)) (concatenate 'string  (subseq s 0 1) (subseq (car (elt ls z)) 0 1) (subseq s 1))))
	     (setf (elt ls k) (cons (car (elt ls k)) (concatenate 'string  (subseq s 0 1) (subseq (car (elt ls k)) 0 1) (subseq s 1))))
	     (return)
	     ))
       (setf k (+ k 1))	   
       )
    (setf z (+ z 1))
    (remove-cdup ls z)
    )
  )

(defun enum-next (cb num bw mv) ;move est le dernier coup donc on cherche white si black et vice versa
  (let ((ls nil)(nr nil)(wc nil)(bc nil))
    ;(setf *w-candidates* nil)
    ;(setf *b-candidates* nil)
    (setf nr num)(setf num nr)
    (ep-condition bw mv)
     (loop for i below (car (array-dimensions cb)) do
        (loop for j below (cadr (array-dimensions cb)) do
          ;(aref board i j)
             (if (and (equal bw "W") (not (equal  (position (coerce (aref cb i j) 'character) *black-pieces*) nil)))
		 (progn
		   (setf ls (build-candidates cb "B" i j))
		   (if (not (equal ls nil))(setf bc (append bc ls)))
		 ))
	     (if (and (equal bw "B") (not (equal  (position (coerce (aref cb i j) 'character) *white-pieces*) nil)))
		 (progn
		   (setf ls (build-candidates cb "W" i j))
		   (if (not (equal ls nil))(setf wc (append wc ls)))
		 )) 
	     )
          )
     (if (not (equal wc nil))
	 (return-from enum-next (remove-cdup wc 0)))
     (if (not (equal bc nil))
	 (return-from enum-next(remove-cdup bc 0)))
     )
  )

(defun verify-move-allowed (num bw mv)
     ;is move in candidate liste ?
     (setf mv mv) (setf bw bw);to avoid warning compil
     (setf num num) ;idem
  )


;;;;
;;;; nlp english
;;;;
(defun mk-metadata (md)
  (create-seed md 1 1 -1))

(defun mk-token (token md)
  (create-node token)
  (add-seed-to-node md token))

(defun is-psigns (c)
  (let ((i nil))
    (setf i (position (coerce c 'character) *psigns*))
    (if (not (equal i nil)) (return-from is-psigns (aref *psigns* i)))
    )
  )

(defun is-pnum (c)
  (let ((i nil))
    (setf i (position (coerce c 'character) *pnum*))
    (if (not (equal i nil)) (return-from is-pnum (aref *pnum* i)))
    )
  )

(defun is-palpha (c)
  (let ((i nil))
    (setf i (position (coerce c 'character) *palpha*))
    (if (not (equal i nil)) (return-from is-palpha (aref *palpha* i)))
    )
  )

(defun is-pend (c)
  (let ((i nil))
    (setf i (position (coerce c 'character) *pend*))
    (if (not (equal i nil)) (return-from is-pend (aref *pend* i)))
    )
  )

(defun build-blocks (fil)
  (let ((ssx nil)(i 0)(ls nil)(c nil))
    (loop
       (when (>= i (length fil)) (return))
       (setf c (aref fil i))
       (if (not (equal c  #\space))
	   (progn
	     ;(print c)
	     (if (not (equal (is-psigns c) nil))
		 (progn
		   (if (> (length ssx) 0)
		       (progn 
		         (push ssx ls)
		         (setf ssx nil)))
		   (push (string c) ls)
		   ))
             (if (or  (not (equal (is-palpha c) nil))  (not (equal (is-pnum c) nil)))
	         (progn
	           (setf ssx (concatenate 'string ssx (string c))))))
	   (progn
	     (if (> (length ssx) 0)
		 (progn
	           (push ssx ls)
	           (setf ssx nil)))
	     ))
       ;(print ssx)
       (setf i (+ i 1))
       )
    (if (> (length ssx) 0) (push ssx ls))
    (return-from build-blocks (reverse ls))
    ))

(defun prep-seq (seq)
  (let ((s1 nil))
    (setf s1 (format nil "~(~a~)" seq))
    ;1 remove unwanted characters
    (setf s1 (replace-all s1 "§"  ""))
    (setf s1 (replace-all s1 "°"  " "))
    ;2 get back full words
    (setf s1 (replace-all s1 "how's" "how is"))
    (setf s1 (replace-all s1 "what's" "what is"))
    (setf s1 (replace-all s1 "aren't" "are not"))
    (setf s1 (replace-all s1 "ain't" "am not"))
    (setf s1 (replace-all s1 "amn't" "am not"))
    (setf s1 (replace-all s1 "i'm" "i am"))
    (setf s1 (replace-all s1 "i'll" "i will"))
    (setf s1 (replace-all s1 "good bye" "goodbye"))
    (setf s1 (replace-all s1 "we'll" "we will"))
    (setf s1 (replace-all s1 " outta" " out of"))
    (setf s1 (replace-all s1 " gotta" " have got to"))
    (setf s1 (replace-all s1 " gonna" " going to"))
    (setf s1 (replace-all s1 "ldn't" "ld not"))
    (setf s1 (replace-all s1 "can't" "cannot"))
    (setf s1 (replace-all s1 "it's" "it is"))
    (setf s1 (replace-all s1 " ya" " you"))
    (setf s1 (replace-all s1 " yur " " your "))
    (setf s1 (replace-all s1 "how y'all" "how are you all"))
    (setf s1 (replace-all s1 "wanna" "want"))  ;ie "want a" or "want to" 
    (return-from prep-seq s1) 
    )
  )

(defun search-dico (word &optional (dico "10k"))    ;dico "10k" default or "alpha" 
  (let ((fs  nil)(s1 nil)(s2 nil)(i 0))
    (setf fs (concatenate 'string *dicos-path* *dico-10k*))
    (if (equal dico "alpha") (setf fs (concatenate 'string *dicos-path* *dico-eng*)))
    ;(print fs)
    (setf s1 (format nil "~(~a~)" word))
     (with-open-file (stream fs
                      :if-does-not-exist nil
                      :external-format '(:utf-8 :replacement "?"))
      (when stream
      (loop for line = (read-line stream nil)
	 while line do
	   (setf i (+ i 1))
	   (setf s2 (format nil "~(~a~)" line))
	   ;(print s2)
	   (if (equal s1 s2)
	       (progn
	       (close stream) 
	       (return-from search-dico i)))
	   )
      (close stream))
      (return-from search-dico 0)
     )))

(defun get-part-of-speech (sl)
  (let ((pos nil))
    (if (not (equal (search "article" sl) nil)) (setf pos "Article"))
    (if (not (equal (search "adv." sl) nil)) (setf pos "Adverb"))
    (if (not (equal (search "adj." sl) nil)) (setf pos "Adjective"))
    (if (not (equal (search " v." sl) nil)) (setf pos "Verb"))
    (if (not (equal (search "—v." sl) nil)) (setf pos "Verb"))
    (if (not (equal (search " n." sl) nil)) (setf pos "Noun"))
    (if (not (equal (search "—n." sl) nil)) (setf pos "Noun"))
    (if (not (equal (search "pron." sl) nil)) (setf pos "Pronoun"))
    (if (not (equal (search "prep." sl) nil)) (setf pos "Preposition"))
    (if (not (equal (search "conj." sl) nil)) (setf pos "Conjunction"))
    (if (not (equal (search "int." sl) nil)) (setf pos "Interjection"))
    (return-from get-part-of-speech pos)
    ))

(defun search-oxf (word  &optional (p 0))
  (let ((fs  nil)(pos nil)(s1 nil)(s2 nil)(s3 nil)(i 0)(n 0))
    (if (= *debug-mode* 1) (setf p 1))
    (setf fs (concatenate 'string *dicos-path* *dico-oxf*))
    ;(print fs)
    (setf s1 (format nil "~(~a~)" word))
     (with-open-file (stream fs
                      :if-does-not-exist nil
                      :external-format '(:utf-8 :replacement "?"))
      (when stream
      (loop for line = (read-line stream nil)
	 while line do
	   (setf i (+ i 1))
	   (setf s2 (format nil "~(~a~)" line))
	   ;(print s2)
	   (if (>= (length line) (length word))
	       (progn
		 (setf s2 (format nil "~(~a~)" (subseq line 0 (length word))))
		 (if (equal s1 s2)
		     (progn
		       (if (= p 1) (print line))
		       (setf n 49)
		       (if (< (length line) 49) (setf n (length line)))
		       (setf s3 (format nil "~(~a~)" (subseq line 0 n)))
		       (setf pos (get-part-of-speech s3))
		       (close stream)
	               (return-from search-oxf pos)))
	         )))
      (close stream))
      (return-from search-oxf nil)
     )))

(defun build-def (sx)
  (let ((i1 nil)(i2 nil)(i3 0)(rx nil)(s1 nil)(s2 nil)(b1 T))
    (setf i1 (search "1" sx))
    (setf i2 (search "2" sx))
    (setf rx sx)
    (if (and (not(equal i1 nil)) (not(equal i2 nil)))
	(progn
	  (if (> i2 i1) (setf rx (subseq rx (+ i1 1) i2)))))
    (setf rx (replace-all rx "-prep." ""))
    (setf rx (replace-all rx "-adv." ""))
    (setf rx (replace-all rx "adv." ""))
    (setf rx (replace-all rx "-adj." ""))
    (setf rx (replace-all rx "adj." ""))
    (setf rx (replace-all rx " v." ""))
    (setf rx (replace-all rx " n." ""))
    (setf rx (replace-all rx "-v." ""))
    (setf rx (replace-all rx "—v." ""))
    (setf rx (replace-all rx "-n." ""))
    (setf rx (replace-all rx "—n." ""))
    (setf rx (replace-all rx "-pron." ""))
    (setf rx (replace-all rx "pron." ""))
    (setf rx (replace-all rx "prep." ""))
    (setf rx (replace-all rx "-conj." ""))
    (setf rx (replace-all rx "conj." ""))
    (setf rx (replace-all rx "-int." ""))
    (setf rx (replace-all rx " int." ""))
    (setf rx (replace-all rx "predic." ""))
    (setf rx (replace-all rx "^?" ""))
    (setf rx (replace-all rx "\"" ""))
    (setf rx (replace-all rx "§" ""))
    (setf rx (replace-all rx "&" ""))
    (setf rx (replace-all rx "esp." ""))
    (setf rx (replace-all rx " usu." " usually"))
    (loop
       (when (>= i3 (length rx)) (return))
       (setf s1 (elt rx i3))
       (if (equal (string s1) "(") (setf b1 nil))
       (if (equal (string s1) ")")
	   (progn
	     (setf b1 T)
	     (setf s1 "")))
       (if (equal (string s1) "[") (setf b1 nil))
       (if (equal (string s1) "]")
	   (progn
	     (setf b1 T)
	     (setf s1 "")))
       (if (equal b1 T) (setf s2 (concatenate 'string s2 (string s1))))
       ;(print s2)
       (setf i3 (+ i3 1))       
       )
    (setf rx s2)
    (return-from build-def rx) 
    ))

(defun search-oxf2 (word  &optional (ext "simple"))    ;"simple" or "full"
  (let ((fs  nil)(s1 nil)(s2 nil)(tx nil)(i 0)(i1 nil))
    (setf fs (concatenate 'string *dicos-path* *dico-oxf*))
    ;(print fs)
    (setf s1 (format nil "~(~a~)" word))
     (with-open-file (stream fs
                      :if-does-not-exist nil
                      :external-format '(:utf-8 :replacement "?"))
      (when stream
      (loop for line = (read-line stream nil)
	 while line do
	   (setf i (+ i 1))
	   (setf s2 (format nil "~(~a~)" line))
	   (setf tx s2)
	   ;(print s2)
	   (if (>= (length line) (length word))
	       (progn
		 (setf s2 (format nil "~(~a~)" (subseq line 0 (length word))))
		 (if (equal s1 s2)
		     (progn
                       (if (equal ext "simple")(setf tx (build-def tx))(setf tx line))
		       (close stream)
		       (setf i1 (search s1 tx))
		       ;(print tx)
		       ;(print i1)
		       (if (and (not (equal i1 nil)) (<= i1 1)) (setf tx (string-trim " " (subseq tx (+ i1 (length s1))))))
		       ;(setf tx (string-trim " " (replace-all tx s1 "")))
	               (return-from search-oxf2 tx)))
	         ))
	   )
      (close stream))
      (return-from search-oxf2 nil)
     )))

(defun scan-lexicon (word)
  (let ((b1 nil)(pos nil)(dico "none"))
	(if (> (search-dico word) 0)
            (progn
	      (setf b1 t) 
	      (setf dico "10k"))
	    (progn
	      (if (> (search-dico word "alpha") 0)
                  (progn
		    (setf dico "alpha")
		    (setf b1 t)))))
	(if (equal b1 t) (setf pos (search-oxf word)))
	(return-from scan-lexicon (values word pos dico))
    )
  )

(defun explain-blocks (pls)
  (let ((fls nil)(mls nil)(ssx nil))
    (dolist (w pls)
      (if (equal (search w *psigns*) nil)
	  (progn
	    (multiple-value-bind (w1 p1 d1) (scan-lexicon w)
	      (if (equal p1 nil) (setf p1 "none"))
              (if (equal (is-numeric w *dec-sign*) T)
                  (progn
		  (setf p1 "num")
		  (setf d1 "num"))) 
	      (if (equal d1 "none") (push w1 mls))
	      (setf ssx (concatenate 'string w1 "§" p1 "§" d1))
	      (push ssx fls)))
	  (progn
	    (setf ssx (concatenate 'string w "§char§none"))
	    (push ssx fls)))
      )
    (setf fls (reverse fls))
    (return-from explain-blocks (values fls mls))
    ;(print pls)
    ;(print fls)
    ))

(defun apply-round-robin (la)
  (if (equal la nil) (return-from apply-round-robin nil))
  (let ((i nil)(j nil)(nd nil)(b1 0)(b2 0)(d T))
    (dolist (a la)
      (setf i (position (find-node2 a) *node*))
      (setf nd (elt *node* i))
      (setf b2 (getf nd :bias))
      (if (equal d T)
	  (progn
	    (setf d nil)
	    (setf b1 (+ b2 1))))
      (if (< b2 b1)
	  (progn
	    (setf j i)
	    (setf b1 b2)))
      ;(print i)
      )
    (setf nd (elt *node* j))
    (setf b1 (+ (getf nd :bias) 1))
    (mod-bias-node2 j b1)
    ;(print nd)
    ;(print b1)
    (return-from apply-round-robin j)
    ))

(defun collect-answer (&optional (ls *child-answer*))
  (let ((msg nil)(nd nil)(s1 nil)(b1 nil))
    (dotimes (i (length ls))
      (setf nd (elt *node* (elt ls i)))
      (setf b1 (+ (getf nd :bias) 1))
      (mod-bias-node2 (elt ls i) b1)      
      (setf s1 (getf nd :name))
      (setf s1 (concatenate 'string (string-upcase (subseq s1 0 1)) (subseq s1 1 (length s1))))
      (if (not (equal (subseq s1 (- (length s1) 1) (length s1)) ".")) (setf s1 (concatenate 'string s1 ".")))
      (setf msg (concatenate 'string msg s1  (string #\linefeed)))      
      )
    (return-from collect-answer  (string-trim "\"" msg))
    ))

(defun get-answer (i-node)
  (if (equal i-node nil) (return-from get-answer nil))
  (let ((nd nil)(n 0)(la nil)(j 0)(i 0)(k nil)(r nil))
    (setf i (parse-integer i-node))
    (setf *child-answer* (get-child-node i))
    ;(print *child-answer*)
    (setf nd (elt *node* i))
    (setf n (length (getf nd :set-next)))
    (loop
       (when (>= j n) (return))
        (push (elt (getf nd :set-next) j) la)
        (setf j (+ j 1))
       )
    ;(print la)
    (if (and (equal (check-setseed i "question") T)(equal (check-setseed i "best-answer") T) (equal (check-setseed i "round-robin") T))
	(progn
	  (setf r (apply-round-robin la))
	  (return-from get-answer r)))
    (if (and (equal (check-setseed i "question") T)(equal (check-setseed i "auto-query") T))
	(progn
	  (setf r (parse-integer i-node))
	  ;(print "auto-query")
	  (return-from get-answer r)))
    (if (and (equal (check-setseed i "question") T)(equal (check-setseed i "multiple-answer") T))
	(progn
	  (setf r (parse-integer i-node))
	  (return-from get-answer r)))
    (if (and (equal (check-setseed i "declaration") T) (equal (check-setseed i "round-robin") T))
	(progn
	  (setf r (apply-round-robin la))
	  (return-from get-answer r)))
    (if (and (equal (check-setseed i "same-as") T) (> (length la) 0))  
	(progn
          ;(setf nd (find-node2 (pop la))) at modification child-answer pour mult answer 
	  (setf k (position (find-node2 (pop la)) *node*))
	  (setf nd (elt *node* k))
	  (setf *child-answer* (get-child-node k))
	  (dotimes (i1 (length (getf nd :set-next))) (push (elt (getf nd :set-next) i1) la))
	  (if (equal (check-setseed k "round-robin") T) (setf r (apply-round-robin la)))
	  (if (equal (check-setseed k "multiple-answer") T) (setf r k))
	  (return-from get-answer r)
	  ))
    (if (equal (check-setseed i "end-of-conversation") T)
	(progn
          (setf *conversation-proc* nil)
	  (setf r (apply-round-robin la))
	  (return-from get-answer r)
	  ))
    ;no match last try
    (if (> (length la) 0)
	(progn
	  (setf r (apply-round-robin la))
	  (return-from get-answer r)))
    
    (return-from get-answer r)
    )
  )

(defun get-uik (r)
  (let ((tx nil))
    (if (equal r "r")
        (setq tx (with-output-to-string (s)
		   (format s "~s" (read-line)))))
    (if (equal r "m")
        (setq tx (with-output-to-string (s)
               (format s "~s" (add-line)))))
    (setf tx (string-trim "\"" tx))
    (setf tx (replace-all tx '(#\return) " "))
    (setf tx (replace-all tx '(#\linefeed) " "))	
    (return-from get-uik tx)
    )
  )

(defun identify-single-question (q)
  (let ((qs '("what" "who" "when" "how" "where" "why")))
    (dolist (q1 qs)
      (if (equal q q1) (return-from identify-single-question T))
     ))
  )

(defun build-ndn (ls)
  (let ((s1 nil))
  (dolist (w ls)
    (setf s1 (concatenate 'string s1 " " w)))
  (return-from build-ndn (string-trim '(#\space) s1)) 
  ))

(defun filter-token (nd ls2)
  (let ((b1  nil)(stk nil)(lv nil)(s1 nil)(l1 nil)(j nil))
    (dotimes (i (length (getf nd :set-seed)))  ;create long code with set-seed elements
       (setf s1 (format nil "~(~a~)" (elt (getf nd :set-seed) i)))
       (setf stk (concatenate 'string stk s1)))
    ;lv list of set-seed to check
    ;do we have a question
    (setf l1 (tl-split '(#\§) (elt ls2 0)))
    (return-from filter-token T)
    (if (equal (identify-single-question (elt l1 0)) T) (push "question" lv))
    
    (if (= (length lv) 0)(setf b1 T)
	(progn
          (setf j 0)
	  (dolist (v lv)
	    (if (not (equal (search v stk) nil))(setf j (+ j 1)))
	    )
	  (if (= j (length lv))(setf b1 T))
	  ))
    (return-from filter-token b1)	  
    ))

(defun collect-token (ls2)  ;build list of tokens with proba to fit
  (let ((i 0)(s1 nil)(s2 nil)(b1 T)(ego 0)(nd nil)(l1 nil)(j 0)(k 0)(h 0)(pct 0)(lr nil)(no-filter T))
    (loop
       (when (>= i (length *node*)) (return))
       (setf nd (elt *node* i))
       (setf s1 (getf nd :name))
       (setf s2 (prep-seq s1))
       (setf s2 (replace-all s2 '(#\space) ""))   ;node name read, no space
       (setf h (length s2))
       ;if filter OK
       ;(if (equal (check-setseed i "question") T)
       ;(if (equal (filter-token nd ls2) T)     
       (if (equal no-filter T)     
	   (progn 
             (setf k 0)
	     (setf ego 0)
               (dolist (g ls2)
	          (setf l1 (tl-split '(#\§) g))	   
	          (if (not (equal (elt l1 1) "char"))
	              (progn
			(if (equal b1 T) (setf j (+ j (length (elt l1 0)))))
			(if (equal (elt l1 0) (format nil "~(~a~)" *myname*))(setf ego (+ ego 1)))
		       (if (not (equal (search (elt l1 0) s2) nil))(setf k (+ k (length (elt l1 0)))))
		     ))
	        )
	       ;stop calc j
	       (setf b1 nil)
	       ;calc score %	       
	       (setf pct (float (/ (* k 100) j)))
	       ;(print pct)
	       (if (and (< h j) (equal (- j h) (length *myname*)) (> ego 0)) (setf pct (float (/ (* k 100) (- j (length *myname*))))))
	       ;(print pct)
               ;(if (and (<= j 10) (> h j))
	       (if (> h j)
		   (progn
                     (setf pct (* pct (float (/ j h))))
		     ))

	       ;(print ego)
               ;(print s2)
	       ;(print ls2)
	       ;(print h)
               ;(print j)
               ;(print k)
               ;(print pct)
               (if (>= pct *pct-answer*)
	           (progn
	             (push (concatenate 'string (format nil "~a" i) "§" (format nil "~a" pct)) lr) 
	             ))
	 ))
         (setf i (+ i 1))
       )
    ;(print lr)
    (return-from collect-token lr)))

(defun get-best-match (lr)
  (let ((in1 nil)(in2 nil)(p1 0)(p2 0)(l1 nil))
    ;(setf p1 (float 0))
    ;(setf p2 (float 0))
    (dolist (r lr)
      (setf l1 (tl-split '(#\§) r))
      ;(format nil "~v$" ix px) ix is precison example 3 and px is the number
      ;(setf p2 (coerce (format nil "~v$" 2 (elt l1 1)) 'float))
      (setf p2 (read-from-string (elt l1 1)))
      (setf in2 (elt l1 0))
	    (if (> p2 p1)
		(progn
		  (setf p1 p2)
		  (setf in1 in2)))
     )
    ;(print in1)
    (return-from get-best-match in1)
    ))

(defun eval-token (ls2)
  (let ((lr nil)(i-node nil)(i 0))
    (setf lr (collect-token ls2))
    (if (> (length lr) 0)
        (progn
	  (setf i-node (get-best-match lr))
	  (setf i (parse-integer i-node))
	  (setf *entry-node* i)
	  (mod-bias-node2 i (+ (getf (elt *node* i) :bias) 1))))
    ;(print i-node)
    (return-from eval-token i-node)
    )
  )

(defun build-multanswer (sdef)
  (let ((s1 nil))
    (setf s1 (concatenate 'string s1 "(let ((s nil)) (setf s §" sdef "§) (setf s (format nil §~a~%§ s))
                  (setf s (concatenate 'string s (collect-answer))) (set-message s))"))
     (return-from build-multanswer s1)
    ))

(defun build-whatis (sdef)
  (let ((s1 nil))
    (setf s1 (concatenate 'string s1 "(let ((s nil)) (setf s §" sdef "§) (set-message s))"))
    (return-from build-whatis s1) 
    ))

(defun check-whatis (ls2)
  (let ((l1 nil)(rs nil)(m nil)(w nil)(s1 nil)(k 0))
     (dolist (g ls2)
       (setf l1 (tl-split '(#\§) g))
       (if (not (equal (elt l1 1) "char"))
	   (progn
	     (setf k (+ k 1))
             (if (equal (elt l1 0) "what") (setf rs (concatenate 'string rs "1")))
	     (if (equal (elt l1 0) "is") (setf rs (concatenate 'string rs "2")))
	     (if (and (equal rs "12") (equal (elt l1 0) "a")) (setf s1 "a"))
	     (if (and (equal rs "12") (equal (elt l1 0) "an")) (setf s1 "an"))
	     (if (and (not (equal (elt l1 0) "a")) (not (equal (elt l1 0) "an")) (not (equal (elt l1 0) "is")) (= k (length ls2)) (equal rs "12"))
		 (progn
		   (setf w (elt l1 0))
                   (if (equal (elt l1 1) "Noun") (setf m (concatenate 'string "What is " s1 " " w))
		      (setf m (concatenate 'string "What is " w)))
		   )
		 )
	     (if (> (length w) 0) (setf rs (concatenate 'string rs (write-to-string k))))
	     )
       )
       )
     ;(print ls2)
     ;(print rs)
     ;(print w)
     ;(print m)
     (return-from check-whatis (values w m))
  ))

(defun create-whatis (w m)
  (let ((nm nil)(df nil))
    (setf df (search-oxf2 w))
    ;insert the valid knowledge here that could potentially modify df
    (if (or (equal *learning-mode* 1) (equal *learning-mode* 2))
	(progn
          (setf df (ask-oracle w df))
	  ;(print df)
	  ))
    (if (> (length df) 0)
	(progn
          (mk-token m "auto-query")
          (add-seed-to-node "question" m)
	  (mod-mathfun-node m "run-cadac")
	  (add-next-to-node m m)
          (setf nm (mk-cadac-node m))
	  (if (> (length nm) 0) (update3-desc-seed nm (build-whatis df)))
	  (return-from create-whatis m)
          ))
    (return-from create-whatis nil)
    ))

(defun pattern-whatis (ls2)
  (multiple-value-bind (w m) (check-whatis ls2)
    (if (> (length m) 0)
	(progn
          (if (equal (get-learning-auth) T) (return-from pattern-whatis (create-whatis w m)))
	  ))
    )
  (return-from pattern-whatis nil))

(defun build-dialog (message answer q-node r-node)
  (let ((xd (list :message message :answer answer :q-node q-node :r-node r-node)))
    (push xd *dialog*)
    ))

(defun show-dialog ()
  (dolist (xd (reverse *dialog*))
    (format t "~{~a:~10t~a~%~}~%" xd)))

(defun eval-dialog (i-node)
  (let ((k 0)(n1 nil)(nd nil)(k1 nil))
    (dotimes (i (length *child-answer*))
      (if (equal i-node (elt *child-answer* i))(setf k 1)))
    (if (> k 0)
	(progn
          (dotimes (i1 (length *dialog*))
            (dotimes (i2 (length *child-answer*))
              (if (and (equal (getf (elt *dialog* i1) :r-node) (elt *child-answer* i2))
		       (equal (is-recurrent (elt *node*  (getf (elt *dialog* i1) :q-node))) nil))
                  (progn
		  (setf k (+ k 1))
		  (return)))))
	  ))
    ;(print k)
    ;case 1 same question again
    (if (> k 1)
        (progn
          (setf n1 (position (find-node2 "same question over and over again") *node*))
	  ;(setf *repl-msg* "Again! ")
	  (if (not (equal n1 nil))
	      (progn
               (setf nd (elt *node* n1))
	       ;(if (<= k (+ (length (getf nd :set-next)) 1)) (setf k1 (- k 2)) (setf k1 (random (length (getf nd :set-next)))))
               (setf k1 (random (length (getf nd :set-next))))
	       (setf *repl-msg* (concatenate 'string *repl-msg* (elt (getf nd :set-next) k1)))))	  
	  ))
    ))

(defun conversation-v1 (&optional (rdr "r") (rec nil))    ;rdr reader "r" read-line ie 1, add-line "m" multiple, rec stored pattern
  (let ((ln nil)(sx nil)(ls1 nil)(ls2 nil)(mls nil)(r nil)(i-node nil)(nd nil)(pt nil)(m1 nil))
    (setf *last-answer* nil)
    (setf *child-answer* nil)
    (setf *entry-node* nil)
    (setf *repl-msg* nil)
    (if (equal rec nil) (setf ln (get-uik rdr)) (setf ln rec))
    (if (= (length ln) 0) (return-from conversation-v1)) ; put some fun here
    (setf sx (prep-seq ln))
    (setf ls1 (build-blocks sx))
    (multiple-value-bind (a1 a2) (explain-blocks ls1)
      (setf ls2 a1)
      (setf mls a2))
    ;(print (length mls)) 
    (if (= (length mls) 0)
	(progn
	  (if (and (= *voice-repeat* 1) (equal rec nil)) (avatar-tk2 (concatenate 'string "Your message. " ln)))
	  (setf r (eval-token ls2))
	  (setf i-node (get-answer r))
	  (if (not (equal i-node nil))
	      (progn
		(setf nd (elt *node* i-node))
		(eval-dialog  i-node)
		(if (equal (is-cadac nd) T) (run-cadac nd)
		    (progn
		      (set-message (getf nd :name))
		      ))
		)
              (progn
                (if (equal pt nil)
		    (progn    ; search patterns
		      (setf pt T)
		      (setf m1 (pattern-whatis ls2))
		      (if (not (equal m1 nil)) (conversation-v1 "r" m1))
		      ))
		  )
	      )))
    (build-dialog ln *last-answer* *entry-node*  i-node)
    (if (= *debug-mode* 1)
	(progn
	  (print ln)
	  (print sx)
	  (print ls1)
	  (print ls2)
	  (print mls)))
    )
  )

(defun start-conversation ()
  (ignore-errors
    (let ((v nil))
      (setf v v)
      (setf *conversation-proc* T)
      (setf *dialog* nil)
    (loop
       (when (equal *conversation-proc* nil) (return))
       (setf v (conversation-v1))
       (terpri)
	 )
    )
    ))

;;lower cases
;;(format t "~(~a~)" "HELLO WORLD")
;;upper cases
;;(format t "~@:(~a~)" "hello world")
;;capitalize all words
;;(format t "~:(~a~)" "HELLO WORLD")
;;capitalize first letter
;;(format t "~@(~a~)" "hello world") 
;;\r is the character #\return in Common Lisp.
;;\n is the character #\linefeed in Common Lisp.
;(position (find-node2 "atalia") *node*)
;(nth 2 '("Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday"))
;(elt '("Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday") 2)

